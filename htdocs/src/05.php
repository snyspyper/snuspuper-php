<head>
    <title>Учи-мучи гачимучи</title>
</head>

<body leftmargin="50" rightmargin="50" topmargin="50" bottommargin="50">
<font face="serif" size="+1">
<button>
    <a href="IV.php">Previous Lvl</a>
</button>
<button>
    <a href="VI.php">Next Lvl</a>
</button>

<h2>Операторы</h2>
<h3>Приоритет операторов</h3>
Если приоритет операций равны, то будут ли они выполняться слева направо или справа на лево определяется их ассоциативностью.<br>
У "-" ассоциативность левая, это значит, что выражение 1 - 2 - 3 будет вычисляться в порядке (1 - 2) - 3.<br>
У "=" ассоциативность правая, значит $a = $b = $c --> $a = ($b = $c).<br>
Однако есть не ассоциативные операторы. Они не могут использоваться совместно с одинаковым приоритетом. Например, 1 < 2  > 1 не будет работать.<br><br>

Порядок выполнения операторов
<table border="5">
    <tr>
        <th>
            Ассоциативность
        </th>
        <th>
            Оператор
        </th>
    </tr>
    <tr>
        <th>
            (н/а)
        </th>
        <th>
            clone new
        </th>
    <tr>
        <th>
            правая
        </th>
        <th>
            **
        </th>
    </tr>
    <tr>
        <th>
            (н/а)
        </th>
        <th>
            ++ -- ~ (int) (float) (string) (array) (object) (bool) @
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            instanceof
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            !
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            * / %
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            + - .
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            << >>
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            < > <= >=
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            == != === !== <> <=>
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            &
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            ^
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            |
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            &&
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            ||
        </th>
    </tr>
    <tr>
        <th>
            правая
        </th>
        <th>
            ??
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            ? :
        </th>
    </tr>
    <tr>
        <th>
            правая
        </th>
        <th>
            = += -= *= **= /= .= %= &= |= ^= <<= >>= ??=
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            yeld from
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            yeld
        </th>
    </tr>
    <tr>
        <th>
            н/а
        </th>
        <th>
            print
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            and
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            xor
        </th>
    </tr>
    <tr>
        <th>
            левая
        </th>
        <th>
            or
        </th>
    </tr>
    </tr>
</table>

<h3>Арифметические операторы</h3>
Тут нет ничего интересного, кроме как +$a, оператор идентичности, конвертация в int или float, что более подходит.<br>
Для целочисленного деления используется функция <font color="magenta">intdiv()</font>.<br>
При делении по модулю операнды преобразуются в целые числа, то есть, отбрасывается дробная часть. Для деления по модулю вещественных чисел используется функция <font color="magenta">fmod()</font>.<br>
И ещё: результат от % будет иметь тот же знак, что и левый операнд, то есть, делимое:<br>
<?php
    echo ( 7 %  3) . "<br>";
    echo (-7 %  3) . "<br>";
    echo ( 7 % -3) . "<br>";
    echo (-7 % -3) . "<br>";
?>

<h3>Оператор присваивания</h3>
Присвоение копирует значение оргинального выражения и устанавливает его в левый операнд.<br>
Исключением является присвоение по значению типа object. В этом случае присваивается по ссылке. Принудительное копирование происходит при помози ключслова <font color="magenta">clone</font>.<br>

<h3>Присваивание по ссылке</h3>
Для присвоения по ссылке используется конструкция $var = &$othervar;. При таком присваивании обе переменные указывают на одни и те же данные, в следствии чего изменение значения одной тз этих пременных изменит изначальные данные. Пример:<br>
<pre><--Source--></pre>
<?php
    $a =   5;
    $b = &$a;
    ++$b;
    echo "$a and $b<br>";
    $a += 18;
    echo "$a and $b<br>";
?>
<br>
Оператор <font color="magenta">new</font> автоматически возвращает ссылку, так что конструкция по типу $a = &new C; является ошибочной.<br>

<h3>Побитовые операторы</h3>

<table border="5">
    <tr>
        <th>
            <pre>$a & $b</pre>
        </th>
        <th>
            И
        </th>
        <th>
            Устанавливаются только те биты, которые установлены и в $a, и в $b.
        </th>
    </tr>
    <tr>
        <th>
            <pre>$a | $b</pre>
        </th>
        <th>
            ИЛИ
        </th>
        <th>
            Устанавливаются только те биты, которые есть в $a и/или в $b.
        </th>
    </tr>
    <tr>
        <th>
            <pre>$a ^ $b</pre>
        </th>
        <th>
            Исключающее ИЛИ
        </th>
        <th>
            Устанавливаются только те биты, которые есть или в $a, или в $b, только не в обоих одновременно.
        </th>
    </tr>
    <tr>
        <th>
            <pre> ~ $a</pre>
        </th>
        <th>
            Отрицание.
        </th>
        <th>
            Устанавливаются только те биты, которых нет в $a и наоборот
        </th>
    </tr>
    <tr>
        <th>
            <pre>$a << $b</pre>
        </th>
        <th>
            Сдвиг влево.
        </th>
        <th>
            Все биты переменной $a сдвигаются на $b позиций влево(умножение на 2 $b количество раз).
        </th>
    </tr>
    <tr>
        <th>
            <pre>$a >> $b</pre>
        </th>
        <th>
            Сдвиг вправо.
        </th>
        <th>
            Все биты переменной $a сдвигаются на $b позиций вправо(деление на 2 $b количество раз).
        </th>
    </tr>
</table>
Побитовые операции не работают со строками.<br>
Если оба операнда для &, | и ^ строки, то операция будет производиться с кодами ASCII всех символов строки и в результате вернёт строку. Во всех остальных случаях, оба операнда будут преобразованы к целому и результатом будет целое число.<br>
Если операнд для ~ строка, то операция будет производиться с кодами ASCII всех символов строки и в результате вернёт строку, в ином случае как операнд, так и результат, будут считаться целыми. <br>

<h3>Операторы сравнения</h3>
Единственное, что необычно, это операция космического корабля, "spaceship": $a <=> $b. Короче, если левый операнд больше правого, то возвращается 1, если оба равны, то 0, иначе -1.<br>
В случае, если оба операнда являются численными строками или один операнд является числом, а другой - численной строкой, то сравнение выполняется численно. Эти правила также применяются к оператору switch.<br><br>


Сравнение других типов.
<table border="5">
    <tr>
        <th>Тип операнда 1</th>
        <th>Тип операнда 2</th>
        <th>Результат</th>
    </tr>
    <tr>
        <th>null или string</th>
        <th>string</th>
        <th>null преобразуется в ""</th>
    </tr>
    <tr>
        <th>bool или null</th>
        <th>что угодно</th>
        <th>преобразуется в тип bool, false < true</th>
    </tr>
    <tr>
        <th>object</th>
        <th>object</th>
        <th>встроенные классы могут определять свои правила сравнения, объекты разных классов не сравниваются</th>
    </tr>
    <tr>
        <th>string, resource, int или float</th>
        <th>string, resource, int или float</th>
        <th>строки и ресурсы переводятся в числа</th>
    </tr>
    <tr>
        <th>array</th>
        <th>array</th>
        <th>массивы с меньшим количеством элементов считаются меньше, если ключ из первого операнда не найден во втором операнде -<br> массивы не могут сравниваться, иначе идёт сравнение соответствующих значение</th>
    </tr>
    <tr>
        <th>array</th>
        <th>что угодно</th>
        <th>тип array всегда больше</th>
    </tr>
    <tr>
        <th>object</th>
        <th>что угодно</th>
        <th>тип object всегда больше</th>
    </tr>
</table><br><br>

Алгоритм сравнения обычных массивов.
<pre><--Source--></pre>
<?php
    function compare_array($op1, $op2)
    {
        if (count($op1) < count($op2))
            return -1;
        elseif (count($op1) > count($op2))
                return 1;

        foreach ($op1 as $key => $value)
        {
            if (!array_key_exists($key, $op2))
                return null;
            elseif ($value < $op2[$key])
                return -1;
            elseif ($value > $op2[$key])
                return 1;
        }
        return 0;// $op1 == $op2
    }
?>
<br><br>
Из-за внутреннего строения типа float не нужно проверять на равенство два числа на равенство с плавающей точкой.

<h3>Тернарный оператор</h3>
Выражение (expr1) ? (expr2) : (expr3);. Тернарная операция трактуется как результат выражения. Это очень важно, если вы хотите вернуть переменную по ссылке. Выражение return $var == 42 ? $a : $b; не будет работать функции, возвращающей значение по ссылке.<br>

<h3>Оператор объединения с null</h3>
Выражение (expr1) ?? (expr2) вычисляется так: возвращается expr2, если expr1 -- null, иначе -- expr1. Этот оператор является выражением. Нельзя использовать в качестве возвращаемого значения в функциях, возвращающих по ссылке.<br>
Так же, он может быть и вложен.<br>
<pre><--Source--></pre>
<?php
    $foo = null;
    $bar = null;
    $baz =    1;
    $fiz =    2;

    echo $foo ?? $bar ?? $baz ?? $fiz;
?>
<pre><--Source--></pre>

<h3>Оператор управления ошибками</h3>
PHP поддерживает один оператор управления ошибками: @. Если он предшествует какому-то выражению в PHP-коде, любые сообщения об ошибках, генерируемые этим выражением, будут подавлены.<br>

<h3>Операторы исполнения</h3>
PHP поддерживает один оператор исполнения: обраные кавычки(``). PHP попытается выполнить строку как консольную команду, и вернёт полученный вывод. Использование обратных кавычек аналогично исползованию функции <font color="magenta">shell_exec()</font>.
<pre><--Source-->
<?php
    $output = `uname -a`;
    echo $output;
?>
<--Source--></pre>

<h3>Операторы инкремента и декремента</h3>
Операторы и/д влияют только на числа и строки.

<h3>Логические операторы</h3>
Смысл двух разных вариантов для операторов И и ИЛИ в разности их приоритетов

<h3>Операторы, работающие с массивами</h3>
<table border="5">
    <tr>
        <th>
            $a + $b
        </th>
        <th>
            Объединение
        </th>
        <th>
            Объединение двух массивов
        </th>
    </tr>
    <tr>
        <th>
            $a == $b
        </th>
        <th>
            Равно
        </th>
        <th>
            истина в том случае, если $a и $b содержат одни и те же пары ключ/значение
        </th>
    </tr>
    <tr>
        <th>
            $a === $b
        </th>
        <th>
            Тождевственно равно
        </th>
        <th>
            истина в том случае, если $a и $b содержат одни и те же пары ключ/значение в том же самом порядке и того же типа
        </th>
    </tr>
    <tr>
        <th>
            $a != $b
        </th>
        <th>
            Не равно
        </th>
        <th>
            истина, если массивы не равны
        </th>
    </tr>
    <tr>
        <th>
            $a <> $b
        </th>
        <th>
            то же самое
        </th>
        <th>
            то же самое
        </th>
    </tr>
    <tr>
        <th>
            $a !== $b
        </th>
        <th>
            Тождевственно не равно
        </th>
        <th>
            истина, если массив $a тождевственно не равен $b
        </th>
    </tr>
</table>

Оператор + возвращает левый массив, к которому был присоединён правы массив. Для ключей, которые существуют в обоих массивах, будут использованы значения из левого массива, а соответствующие им элементы из правого массива будут проигнорированы.
<pre><--Source-->
<?php
    $a = 
    [
        "a" => "apple",
        "b" => "banana"
    ];

    $b =
    [
        "a" => "pear",
        "b" => "strawberry",
        "c" => "cherry"
    ];

    $c = $a + $b;
    echo "Объединение \$a и \$b" . PHP_EOL;
    var_dump($c);

    $c = $b + $a;
    echo "Объединение \$b и \$a" . PHP_EOL;
    var_dump($c);

    $a += $b;
    echo "Объединение \$a += \$b" . PHP_EOL;
    var_dump($a);
?>
<--Source--></pre>


<h3>Оператор проверки типа</h3>
Оператор <font color="magenta">instanceof</font> используется для проверки того, является ли текущий объект экземпляром указанного класса.<br>
<pre><--Source-->
<?php
    class MyClass{}

    class NotMyClass{}

    $a = new MyClass;
    var_dump($a instanceof    Myclass) . PHP_EOL;
    var_dump($a instanceof NotMyClass) . PHP_EOL;
?>
<--Source--></pre>
При сравнении экземпляра дочернего класса с родительским классом всегда будет <font color="green">true</font>.


<button>
    <a href="IV.php">Previous Lvl</a>
</button>
<button>
    <a href="VI.php">Next Lvl</a>
</button>
